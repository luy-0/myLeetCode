# 力扣解题笔记-2020.09

2020年8月22日 "再度"开始刷力扣

既然决定不读研就好好刷题学工程吧

每周七题以上. 如果遇到考试周等特别情况可以提前一周完成任务, 不得向后拖延.

## 2020年9月1日-week1

主题:链表+字符串

### [141] 环形链表

简单题

检测给出的链表中有没有环

第一下自己没有想出来, 看了题解. 

方法1: 哈希表储存节点的出现次数-------只要定义的是`map<listNode*, int>` 就可以了.

方法2: 很巧妙, 快慢节点, 快每次走2步, 慢每次走1步. 如果有环快慢指针会相遇, 没有环则快指针会走到尽头.

注意: 方法2最后的判断应该是: `fNode != nullptr && fNode->next != nullptr` 因为`fnode`每次走两步!



### [344] 反转字符串

简单题

双指针, 左右端交换, 向中间靠拢

记得要 `i++, j--` ! 第二次忘了!

小技巧: 3次异或交换

```
s[left] ^= s[right]
s[right] ^= s[left]
s[left] ^= s[right]
```

即可实现两个元素交换,且不用花费额外空间,还快

此外还可以使用算法库中的 [reverse(begin, end)](https://zh.cppreference.com/w/cpp/algorithm/reverse)

## 2020年9月2日-week2

主题: 字符串

### [7] 整数反转

简单题(大概)

单看数据反转这个要求其实不难, x每次退栈个位数, re此时入栈. 问题在于涉及到溢出的判断.

这里考察了一下下对于数据储存的理解是否深刻. 见[题解](https://leetcode-cn.com/problems/reverse-integer/solution/hua-jie-suan-fa-7-zheng-shu-fan-zhuan-by-guanpengc/)

此外, 在`limit.h`中储存的INT_MAX等数据

## 2020年9月3日-week2

主题:字符串

### [387] 字符串中的第一个唯一字符

简单题

解法一,hash+两次遍历,很容易想到

解法二,不借助hash 该字符第一次出现的位置和最后一次出现的位置一样，就证明不重复。

函数

```c++
#include <string>
string s;
char ch;
s.find_first_of(ch);	//返回索引,找不到返回-1
s.find_last_of(ch);		//同上
```

小优化: 无论字符串多长都只需要26次循环(常数级优化):

1. 若字符串长度<26 同上

2. 若>26, 将26个字母遍历, 找到第一个出现一次的. 

3. 

   ```c
   for(int i = 0;i<length;i++){
       char c = s[i];
       int pre = s.find_first_of(c);
       if(pre!=-1 && pre==s.find_last_of(c))
       	return pre;
   }
   return -1;
   ```

   

   

## 2020年9月4日-week2

主题: 字符串

### [242] 有效的字母异位词

Hash(数组也行) 几次遍历

为了检查 t 是否是 s 的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 S 和 T 都只包含 A−Z 的字母，所以一个简单的 26 位计数器表就足够了

我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 s 字母的频率，用 t 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。

### [125] 验证回文串

简单题 

回文是很熟悉的题型了, 双指针，栈，reverse都行. 这一题着重于String的一些API调用

以下这些函数定义在` <string>` 里

| 数值转换                                                     |                                               |
| ------------------------------------------------------------ | --------------------------------------------- |
| ✔[stoi  stol  stoll](https://zh.cppreference.com/w/cpp/string/basic_string/stol)(C++11)(C++11)(C++11) | 转换字符串为有符号整数 (函数)                 |
| [stoul  stoull](https://zh.cppreference.com/w/cpp/string/basic_string/stoul)(C++11)(C++11) | 转换字符串为无符号整数 (函数)                 |
| [stof  stod  stold](https://zh.cppreference.com/w/cpp/string/basic_string/stof)(C++11)(C++11)(C++11) | 转换字符串为浮点值 (函数)                     |
| ✔[to_string](https://zh.cppreference.com/w/cpp/string/basic_string/to_string)(C++11) | 转换整数或浮点值为 `string` (函数)            |
| [to_wstring](https://zh.cppreference.com/w/cpp/string/basic_string/to_wstring)(C++11) | 转换整数或浮点值为 `wstring` (函数)           |
| 范围访问                                                     |                                               |
| ✔[begin  cbegin](https://zh.cppreference.com/w/cpp/iterator/begin)(C++11)(C++14) | 返回指向容器或数组起始的迭代器 (函数模板)     |
| ✔[end  cend](https://zh.cppreference.com/w/cpp/iterator/end)(C++11)(C++14) | 返回指向容器或数组结尾的迭代器 (函数模板)     |
| [rbegin  crbegin](https://zh.cppreference.com/w/cpp/iterator/rbegin)(C++14) | 返回指向一个容器或数组的逆向迭代器 (函数模板) |
| [rend  crend](https://zh.cppreference.com/w/cpp/iterator/rend)(C++14) | 返回容器或数组的逆向尾迭代器 (函数模板)       |
| ✔[size  ssize](https://zh.cppreference.com/w/cpp/iterator/size)(C++17)(C++20) | 返回容器或数组的大小 (函数模板)               |
| ✔[empty](https://zh.cppreference.com/w/cpp/iterator/empty)(C++17) | 检查容器是否为空 (函数模板)                   |
| [data](https://zh.cppreference.com/w/cpp/iterator/data)(C++17) | 获得指向底层数组的指针 (函数模板)             |

以下这些函数定义在` <cctype.h>` 里

| 函数                                                         | 参数返回值皆为int                 |
| ------------------------------------------------------------ | --------------------------------- |
| ✔[isalnum](https://zh.cppreference.com/w/cpp/string/byte/isalnum) | 检查字符是否为字母或数字 (函数)   |
| ✔[isalpha](https://zh.cppreference.com/w/cpp/string/byte/isalpha) | 检查字符是否为字母 (函数)         |
| ✔[isdigit](https://zh.cppreference.com/w/cpp/string/byte/isdigit) | 检查字符是否为数字 (函数)         |
| ✔[isupper](https://zh.cppreference.com/w/cpp/string/byte/isupper) | 检查字符是否为大写字符 (函数)     |
| ✔[islower](https://zh.cppreference.com/w/cpp/string/byte/islower) | 检查字符是否为小写 (函数)         |
| [isxdigit](https://zh.cppreference.com/w/cpp/string/byte/isxdigit) | 检查字符是为十六进制字符 (函数)   |
| [iscntrl](https://zh.cppreference.com/w/cpp/string/byte/iscntrl) | 检查字符是否为控制字符 (函数)     |
| [isgraph](https://zh.cppreference.com/w/cpp/string/byte/isgraph) | 检查字符是否为图形字符 (函数)     |
| [isspace](https://zh.cppreference.com/w/cpp/string/byte/isspace) | 检查字符是否为空白间隔字符 (函数) |
| [isblank](https://zh.cppreference.com/w/cpp/string/byte/isblank)(C++11) | 检查字符是否为空白字符 (函数)     |
| [isprint](https://zh.cppreference.com/w/cpp/string/byte/isprint) | 检查字符是否为打印字符 (函数)     |
| [ispunct](https://zh.cppreference.com/w/cpp/string/byte/ispunct) | 检查字符是否为标点符 (函数)       |
| ✔[tolower](https://zh.cppreference.com/w/cpp/string/byte/tolower) | 转换字符为小写 (函数)             |
| ✔[toupper](https://zh.cppreference.com/w/cpp/string/byte/toupper) | 转换字符为大写 (函数)             |

此外还有一个将字母转化大小写的小技巧

> 字母大小写转换的方法：
>
> 1. 统一转成大写：ch & 0b11011111 简写：ch & 0xDF
> 2. 统一转成小写：ch | 0b00100000 简写：ch | 0x20
>
> 比较的时候注意加上小括号哦，因为位运算优先级比较低。

但是必须先保证转化的本身就是字母字符  [原理参考这里,很简单](https://blog.csdn.net/weixin_44190113/article/details/106106495)



## 2020年9月5日

主题: 字符串

### [38] 外观数列

很有意思的题目, 虽然是简单题但是dp问题还是折腾了快一个小时.

> 给定一个正整数 *n*（1 ≤ *n* ≤ 30），输出外观数列的第 *n* 项。
>
> 注意：整数序列中的每一项将表示为一个字符串。
>
> 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：
>
> ```
> 1.     1
> 2.     11
> 3.     21
> 4.     1211
> 5.     111221
> ```
>
> 第一项是数字 1
>
> 描述前一项，这个数是 `1` 即 “一个 1 ”，记作 `11`L
>
> 描述前一项，这个数是 `11` 即 “两个 1 ” ，记作 `21`
>
> 描述前一项，这个数是 `21` 即 “一个 2 一个 1 ” ，记作 `1211`
>
> 描述前一项，这个数是 `1211` 即 “一个 1 一个 2 两个 1 ” ，记作 `111221`

先获取第`n-1`项, 然后对其进行分析.

具体的分析代码就不贴了, 补充一下Vector转String的操作:

[str.assign()](https://zh.cppreference.com/w/cpp/string/basic_string/assign)

> template< class InputIt >
> basic_string& assign( InputIt first, InputIt last );
>
> template< class InputIt >
> constexpr basic_string& assign( InputIt first, InputIt last );

例如 

```c
vector<char> v;
string re;
re.assign(v.begin(),v.end());
```

