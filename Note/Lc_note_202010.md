# 力扣解题笔记-2020.10

## 2020年10月4日

### 面试题 01.08. 零矩阵

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

思路: 扫描两遍

第一遍扫描: 新建两个布尔数组(长度为M和N),分别储存矩阵的横纵坐标是否为零

第二遍扫描: 如果元素的对应任意数组元素为真,清零

### [977] 有序数组的平方

解法一思路很简单, 先平方再排序

解法2: 使用双指针. 指针从两头逐渐向中间移动. 由于数组递增排序,绝对值两头大中间小. 选择更大的数, 平方后赋值在re数组中(注意要从后向前赋值) 

---

## 2020年10月7日

### [75] 颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

题目要求不使用库中的排序算法. 

解法1: 扫描两次.第一次统计各种元素的个数. 第二次重写数组. 不佳

解法2: 使用双指针. 分别指向第一个1和最后一个1.一次遍历时遇到0 ,与A[p++]交换; 遇到2, 与A[q--]交换.

注意: 解法二中, 如果发生了交换, 那么下一个判断的数组还是A[i], 因此i++不能直接写在for循环的末尾循环语句中! 

### [498]对角线遍历

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png)

关键点1: 如果元素的横纵坐标之和是偶数, 说明下一个方向是朝着右上角.

关键点2: 针对边界的修正. 

### [14]  最长公共前缀

这题曾经在2020.09月用CPP实现过. 今天用Java重写了.

以第一个字符串为基准. 对于该串的每个字符是否与后面的所有串的对应位置的字符相同. 如果不同则将该字符前的子串返回.