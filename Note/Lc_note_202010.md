# 力扣解题笔记-2020.10

## 2020年10月4日

### 面试题 01.08. 零矩阵

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

思路: 扫描两遍

第一遍扫描: 新建两个布尔数组(长度为M和N),分别储存矩阵的横纵坐标是否为零

第二遍扫描: 如果元素的对应任意数组元素为真,清零

### [977] 有序数组的平方

解法一思路很简单, 先平方再排序

解法2: 使用双指针. 指针从两头逐渐向中间移动. 由于数组递增排序,绝对值两头大中间小. 选择更大的数, 平方后赋值在re数组中(注意要从后向前赋值) 

---

## 2020年10月7日

### [75] 颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

题目要求不使用库中的排序算法. 

解法1: 扫描两次.第一次统计各种元素的个数. 第二次重写数组. 不佳

解法2: 使用双指针. 分别指向第一个1和最后一个1.一次遍历时遇到0 ,与A[p++]交换; 遇到2, 与A[q--]交换.

注意: 解法二中, 如果发生了交换, 那么下一个判断的数组还是A[i], 因此i++不能直接写在for循环的末尾循环语句中! 

### [498]对角线遍历

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png)

关键点1: 如果元素的横纵坐标之和是偶数, 说明下一个方向是朝着右上角.

关键点2: 针对边界的修正. 

### [14]  最长公共前缀

这题曾经在2020.09月用CPP实现过. 今天用Java重写了.

以第一个字符串为基准. 对于该串的每个字符是否与后面的所有串的对应位置的字符相同. 如果不同则将该字符前的子串返回.

---

## 2020年10月9日

### [141] 环形列表

2020年9月份做过了. 使用Java重写.

另外: 逻辑与, 逻辑或具有短路功能. 因此最初的判断只需要

```JAVA
if (head == null || head.next == null)
            return false;
```

即可! 如果head为空引用类型, 后面对next的判断会被短路. 无需担心. 



---

## 2020年10月15日

### [27] 移除元素

快慢指针 [题解](https://leetcode-cn.com/leetbook/read/array-and-string/cv3bv/)

主要问题: 如何判断两个指针的自增条件?

### [485] 最大连续1的个数

同样用双指针,注意判断时需要同时判断前一位的值: 相异再执行,相同直接下一个, 最后返回fast-slow即可

### [209] 长度最小的子数组

这题写的很难受..又是一看就会一写就废

> 给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的 **连续** 子数组，并返回其长度**。**如果不存在符合条件的子数组，返回 0。

第一次写的暴力就忽略了. 最优方法是滑动窗口(双指针的一种):

思想: 若sum小了 fast后移; 若sum大了, slow后移 在此过程中找最小的

问题: 如何把思想转成代码? 如何再这个过程中找到最小的?



算法: (先自己写 再看这个)

```
每一个fast:
if(当前sum较小)
	fast后移
else{
	while(当前sum>=s){
		更新min
		sum中减去slow对应数字
		slow后移
	}
}
```

TODO: 重写

## 2020年10月20日

### [4] 寻找两个正序数组的中位数

Hard题

给两个排序数组, 返回合并后的中位数

方法一: 暴力

先合并, 再求中位数; 问题主要转化成了两个正序数组的合并问题.

返回中位数:不会真有人用双指针吧? 判断元素数目的奇偶, 返回 

```
个数为奇数: nums[len/2]
个数为偶数: (nums[len/2] + nums[len/2-1]) / 2
```

## 2020年10月21日

### [4] 寻找两个正序数组的中位数

方法二:二分查找

在两个数组中进行二分查找,主要的思想还是不变的.(当然写起来问题很多就是了)

建议直接看[官方题解的视频,](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)讲的比较到位

没有太理清楚的点: 在二分查找时,关于奇数的除二,上下取整问题. 以及改变left 和right的时候是`i-1`,`i` 还是 `i+1`呢?

**TODO**

### [11] 盛最多水的容器

双指针. 每次都移动更矮的板子,结果可能更差,但不会错过更好的.

应该是应用很多的思路.

注意: 题目不需要返回最佳时的左右板子,只要最多水的容量即可!

【更新】于2020.11.2 补上证明: 为什么这么做不会错过更大的面积?

### [53] 最大子序和

在九月份时写过C++版本的. 这题主要是动态规划.当时的笔记较为详细.请移步.

## 2020年10月23日

### [15] 三数之和

终于到了久仰大名的三数之和.这是一条非常经典的双指针题目.

> 给定一数组, 找出所有满足和为0的三元组,不能重复.

思路如下: 

对于每一个`a`, 要使得`b+c = -a`. 我们可以在将`b`从小到大的同时将`c`从大到小, 也就是第二重循环和第三重循环实际上是并列的.

```
我们选出的数分别是a,b,c, 它们在数组中的位置分别是first,second,third
sort(nums)
for first = 0..n-1
	if(a不是第一个 && a与nums[first-1]一样)
		continue
		//为了保证不重复
	target = -1 * a		//对于这个a,b+c应该等于target
	third = n-1
	second = first+1
	//并列执行二,三重循环,或者说是双指针
	for second = first+1 .. n-1
            if(b不是a后第一个 && b与nums[second-1]一样)
                continue
                //为了保证不重复
            while nums[first]+nums[second]+nums[third] > 0
                third = third-1
            // 判断是否有 a+b+c==0
            check(first, second, third)
```

当然,这里还可以有一些常数级的优化. 略过不表.

原本的复杂度是`O(n^3)`. 现在的复杂度是`O(N^2)`

> 这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 `O(N^2)`) 减少至 O(N)O(N)。为什么是`O(N)` 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 bb），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为`O(N)`，均摊下来，每次也向左移动一个位置，因此时间复杂度为 `O(N)`。
>
> 注意到我们的伪代码中还有第一重循环，时间复杂度为 `O(N)`，因此枚举的总时间复杂度为 `O(N^2)`
>  )。由于排序的时间复杂度为 `O(N log N)`)，在渐进意义下小于前者，因此算法的总时间复杂度为` O(N^2)`。

### [121] 买卖股票的最佳时机

二刷,一条简单的`dp` 存储目前的最低价和最大收益

```
for i = 0..n-1
	if(curr<minPrice) minPrice=curr;
	if(curr-minPrice>maxProfit) maxProfit=curr-minPrice;
```

## 2020年10月24日

### [42] 接雨水

1. 暴力: 对于每个高度h,找到左边最lm,和右边最大的数rm. 取min(lm,rm)-h的值,若大于0则累计.

   问题在于: 每个高度都要左右扫描一遍 O(n^2)

2. 动态编程

   先扫描两边,记录每个h的`leftMaxVol[]`, `rightMaxVol[]`

   遍历每个高度时,只需要拿两个数组对应的值即可. 

3. 双指针

   很巧妙, 

   定理一：在某个位置`i`处，它能存的水，取决于它左右两边的最大值中较小的一个。

   定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值）

   定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。

   对于位置`left`而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果`left_max<right_max`成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当`left_max<right_max`时，我们就希望去处理left下标，反之，我们希望去处理right下标。

### [238] 除自身以外数组的乘积

题目不让使用除法

和42题类似,先遍历两边, 算出前缀积和后缀积,再第三次遍历的时候相乘.

空间都复杂度的优化:

前缀积可以不用数组, 而用一个整数在最终遍历的时候动态维护. 那么后缀积怎么优化呢? 很鸡贼, 因为题目说不考虑返回数组的空间, 所以把遍历的后缀积放在`ans[]`数组中.....

## 2020年10月27日

### [16] 最接近的三数之和

啊这, 其实和[[15]三数之和](https://leetcode-cn.com/problems/3sum/)基本是完全一致的思路。请直接参照10月23日的笔记。

常数级优化：若`first!=0 && nums[first]==nums[first-1]`, 可直接`continue`；若`tmp3sum == target`,可直接返回，因为没有比自身更接近自身的数了。

### [31] 下一个排列

TODO 这条做的磕磕绊绊的，值得回头再做。比较考验思维。

可以直接看 [题解](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/)。关键点在于：找出规律。先从全降序的入手，找到交换点，最后考虑到逆序。

说几个容易错的点

1. 长度为1的边缘情况
2. 如果全降序，需要全逆序
3. 找第二个交换点时，要考虑到`nums[a]==nums[b-1]`相等的情况。例如 1，5，1；应该是 `1,5`交换，不是`1,1`交换

## 2020年10月28日

### [289] 生命游戏

大名鼎鼎的细胞自动机. 题目本身不难, 关键是如何将规则提取为判断式；同时对规则尽可能地化简。

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

```
for each{
	int livesAround = countLivesCellAround();
	ChangeStatus();
}
```

那么关键问题就变成了，如何计数？又如何改变？有以下问题

1. 如果仅仅使用1/0，那么最大的问题在于，计数时左上方的状态已经被更改过了。

2. 对于上一条，我们可以将原始数组实现储存一份。但是空间开销大。

3. 我们还可以拓展状态为

   ```
   0: 00 死->死 
   1: 01 活->死 
   2: 10 死->活 
   3: 11 活->活
   ```

4. 这样子，如果当前细胞死亡，状态无需改变；如果继续存活，1->3；如果细胞复活，0->2

以上就是本题的主要思路了。

下面介绍一下二位矩阵中，统计周围单元格时对于边界的简便处理手段。

```
int[] dx = { -1, -1, -1, 0, 0, 1, 1, 1 };
int[] dy = { -1, 0, 1, -1, 1, -1, 0, 1 };

for each{
	int nx = row + dx[i];
    int ny = col + dy[i];
    if (nx < 0 || nx >= rows || ny < 0 || ny >= cols) {
    	continue;
    }else{
    	// 正常操作
    }
}
```

## 2020年10月29日

### [442] 数组中重复的数据

> 给定一个整数数组 a，其中1 ≤ a[i] ≤ *n* （*n*为数组长度）, 其中有些元素出现**两次**而其他元素出现**一次**。
>
> 找到所有出现**两次**的元素。

 思考: 考虑到1 ≤ a[i] ≤ n ,那么应该是一一对应的. 

问题:如何将这个信息存储在原有的数组中?能否不影响数组本身信息的存储?

答:由于数字都是正数,我们可以利用符号的转变来存储这一二进制信息(正:未遇见过,负:已遇见过)

```
for each{
	index = nums[i]-1	//index是索引,数字范围1~n,对于0~n-1
	if(nums[index]>0)
		nums[index] * -1
	else
		//说明出现过,添加进结果		
}
```

## 2020年10月30日

### [41] 缺失的第一个正数

利用正负来标记信息

[官方题解](https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/)

##### TODO 重做

### [88] 合并两个有序数组

二刷, 很简单的双指针题目. 从后往前指针移动即可.注意一下其中一个数组完成后将后续部分如何放进去