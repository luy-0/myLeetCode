# 力扣解题笔记-2021.02

这段时间在字节跳动实习，之前没有认真刷题，现在还是得开始刷了。

语言转向 Go 语言，可能会出现比较简单的题目，主要是为了熟悉语言的语法。

## 2021年02月07日

### [665] 非递减数列

看起来是个简单题，实际上暗藏玄机。

> 给你一个长度为 `n` 的整数数组，请你判断在 **最多** 改变 `1` 个元素的情况下，该数组能否变成一个非递减数列。

- 最开始的想法：如果出现非递减的，那么计数，如果次数多于1，那么返回 false

  - 遇到反例：【3，4，1，2】

    这里只会在 4 > 1 的时候判断为非递减，但是并不能在只修正一次的情况下改正数列

- 第二次想法：记录当前的最大值，如果值小于最大值则计数，次数多于1返回false

  - 遇到反例：「3，4，9，5，6」

    「9」污染了最大值，后续的判断都会失效，但是如果把 9 本身修正就可以解决问题

正确的思路：

每次遇到不符合的数字时都将其「修正」：

- 什么是不符合的数字？`nums[i] > nums[i+1] `
  - 例如「3，7，5，6」-> 将 7 修正为 3/4/5 即可ßß，假设默认修改成 `nums[i-1]`
  - 为什么我们不是把 5 修改为 7 呢？就是为了防止会改变后面的大小关系（和6的大小关系）
- 但是，如果是「5，7，3，8」的话，这么修改是行不通的。把 7 修改成 5，不行；但是如果把 3 修改为 7 的话，可以。
- 总结：已知 `nums[i] > nums[i+1]`
  - 可能：`nums[i-1] <= nuns[i+1] ` ，此时使 `nums[i] = nums[i-1]`
  - 或：`nums[i-1] > nuns[i+1] ` ，此时使 `nums[i+1] = nums[i]`

