# 力扣解题笔记-剑指Offer系列

## 树

### [03]数组中重复的数字

> 长度为 n 的数组中所有元素都在 0~n-1 之间。请找出重复的元素。

1. 长度为 n，而所有元素都在 0~n-1 之间。如果没有重复的元素，应该正好是一个萝卜一个坑。

2. 核心思路是：通过某种手段排查出 <元素重复> 这一信息。即， 当我们第二次遇到这个元素时，我们能够得知这个元素是出现过了的。

3. 那么很自然的想法是利用哈希表。两次遍历(放入表中&检索表)，时间 O(n)。空间复杂度 O(n)。

4. 这题的一种巧妙解法是：将元素的值与数组下标对应起来。前面哈希表的用途是：标识这个元素出现的次数，我们也可以这么实现：

   ```
   遇到某个元素，检查<以该元素的值为下标的数组元素的值(的绝对值)>
   	若为正数，说明以前没有遇到过，将其取负
   	若为负数，说明以前遇到过，返回之
   若遍历到结尾，说明没有重复元素或为0，返回0
   ```

   因为题目保证元素是 >=0 的，所以可以放心修改，比较时加上绝对值判断即可。

   这个方法通过数据的符号来存储 <是否出现过> 这一信息，换取了空间复杂度。

   局限性：只能用于数据非负的情况，且不能区分数组是 没有重复元素还是重复元素为0 这两种情况

5. 另一个思路是原书中给出的。还是基于元素的值与数组下标对应的思想。

   ```
   遇到某个元素A，检查<以该元素的值为下标的数组元素B>
   	若A的下标等于A的值，continue
   	若A!=B，说明以前没有遇到过，swap(A,B)
   	若A==B，说明以前遇到过，返回之
   若遍历到结尾，说明没有重复元素
   ```

   每个数字最多交换两次即可得到自己的位置，因此总时间复杂度是 O(n)，空间复杂度为 O(1)



### [04]二维数组中的查找

> 在一个 n*m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]

1. 涉及到有序数组的查找，第一反应自然是二分法。但是本题是局部有序，全局无序，可以这样：

   自上而下遍历行，如果首元素小于目标元素且尾元素大于目标元素，在本行中二分查找

   时间复杂度是 O(mlog(n))，但是解法由于先检测了本行是否可能存在目标元素，因此实际有常数级优化。

2. 原书解法：从右上角开始，如果当前元素小于目标元素，剔除该行。如果大于，剔除该列

   访问到的下标的行最多增加 `n` 次，列最多减少 `m` 次，时间复杂度 O(n+m)。空间复杂度 O(1)



## 链表

### [06]从尾到头打印链表

> 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

1. 本题的关键在于，要求输入与输出是逆序的，而链表是显然的单向。立马想到用栈来实现。

   新建栈，遍历列表并入栈；根据栈的大小新建数组，依次出栈。

   注意：栈中的 pop() 是出栈并删除元素，peek() 函数只出栈，不删除元素。

2. 遍历链表获取长度，新建数组。第 i 个链表结点放入第 len-i 个数组中。

   ~~甚至必用栈来的还要快~~

    

### [18] 删除链表的结点

> 在 O(1)的时间内删除指定的链表节点，给定单向链表的头节点和一个节点指针，删除值。

1. 常规做法无疑是：找到待删除节点的前置节点，改变其指针以实现删除的目的。

2. 显然这样的复杂度是 O(n)。之所以要找前置节点，是因为我们需要删除这个节点——但是，我们也可以不删除当前的节点

   ```
   将目标节点的值重新用后继节点的值赋值，并删除后继节点
   假设 [1,2,3,4,5] 删除[3]
   -> [1,2,3,4,5]	
   -> [1,2,4,4,5]	// 3 复制成 4
   -> [1,2,4,5]	// 删除原来的 4
   ```

3. 但是这样的做法是有漏洞的：如果删除的是最后一个节点，那么是找不到后继节点的，只能老老实实地找到前置节点，并使前置节点的 next 赋为 null

4. 但是这样还是有漏洞的：如果删除节点既没有前置、也没有后继呢？换言之，整个链表只有这一个节点，那么只要处理特殊情况即可。

### [22] 链表中倒数第 k 个节点

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。	
>

1. 思路是简单的，双指针解决。本题的主要注意点是代码的鲁棒性
2. 考虑一下情况：
   1. 传入的链表节点为空
   2. 传入的 k 为0或负数
   3. 传入的 k 大于链表长度
   4. 传入的 k 为1（返回链表最后一个节点）
   5. 传入的 k 为链表长度（返回链表第一个节点）



### [24] 反转链表

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

1. 思路依旧是简单的，依旧是注意鲁棒性
2. 考虑以下情况：
   1. 链表不存在
   2. 链表只有一个节点
3. 提示：哑节点(C语言语境下的"头指针")可以规避大部分特殊情况的判断。