# 力扣解题笔记-剑指Offer系列

## 数组

### [03]数组中重复的数字

> 长度为 n 的数组中所有元素都在 0~n-1 之间。请找出重复的元素。

1. 长度为 n，而所有元素都在 0~n-1 之间。如果没有重复的元素，应该正好是一个萝卜一个坑。

2. 核心思路是：通过某种手段排查出 <元素重复> 这一信息。即， 当我们第二次遇到这个元素时，我们能够得知这个元素是出现过了的。

3. 那么很自然的想法是利用哈希表。两次遍历(放入表中&检索表)，时间 O(n)。空间复杂度 O(n)。

4. 这题的一种巧妙解法是：将元素的值与数组下标对应起来。前面哈希表的用途是：标识这个元素出现的次数，我们也可以这么实现：

   ```
   遇到某个元素，检查<以该元素的值为下标的数组元素的值(的绝对值)>
   	若为正数，说明以前没有遇到过，将其取负
   	若为负数，说明以前遇到过，返回之
   若遍历到结尾，说明没有重复元素或为0，返回0
   ```

   因为题目保证元素是 >=0 的，所以可以放心修改，比较时加上绝对值判断即可。

   这个方法通过数据的符号来存储 <是否出现过> 这一信息，换取了空间复杂度。

   局限性：只能用于数据非负的情况，且不能区分数组是 没有重复元素还是重复元素为0 这两种情况

5. 另一个思路是原书中给出的。还是基于元素的值与数组下标对应的思想。

   ```
   遇到某个元素A，检查<以该元素的值为下标的数组元素B>
   	若A的下标等于A的值，continue
   	若A!=B，说明以前没有遇到过，swap(A,B)
   	若A==B，说明以前遇到过，返回之
   若遍历到结尾，说明没有重复元素
   ```

   每个数字最多交换两次即可得到自己的位置，因此总时间复杂度是 O(n)，空间复杂度为 O(1)



### [04]二维数组中的查找

> 在一个 n*m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]

1. 涉及到有序数组的查找，第一反应自然是二分法。但是本题是局部有序，全局无序，可以这样：

   自上而下遍历行，如果首元素小于目标元素且尾元素大于目标元素，在本行中二分查找

   时间复杂度是 O(mlog(n))，但是解法由于先检测了本行是否可能存在目标元素，因此实际有常数级优化。

2. 原书解法：从右上角开始，如果当前元素小于目标元素，剔除该行。如果大于，剔除该列

   访问到的下标的行最多增加 `n` 次，列最多减少 `m` 次，时间复杂度 O(n+m)。空间复杂度 O(1)



## 链表

### [06]从尾到头打印链表

> 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

1. 本题的关键在于，要求输入与输出是逆序的，而链表是显然的单向。立马想到用栈来实现。

   新建栈，遍历列表并入栈；根据栈的大小新建数组，依次出栈。

   注意：栈中的 pop() 是出栈并删除元素，peek() 函数只出栈，不删除元素。

2. 遍历链表获取长度，新建数组。第 i 个链表结点放入第 len-i 个数组中。

   ~~甚至必用栈来的还要快~~

    

### [18] 删除链表的结点

> 在 O(1)的时间内删除指定的链表节点，给定单向链表的头节点和一个节点指针，删除值。

1. 常规做法无疑是：找到待删除节点的前置节点，改变其指针以实现删除的目的。

2. 显然这样的复杂度是 O(n)。之所以要找前置节点，是因为我们需要删除这个节点——但是，我们也可以不删除当前的节点

   ```
   将目标节点的值重新用后继节点的值赋值，并删除后继节点
   假设 [1,2,3,4,5] 删除[3]
   -> [1,2,3,4,5]	
   -> [1,2,4,4,5]	// 3 复制成 4
   -> [1,2,4,5]	// 删除原来的 4
   ```

3. 但是这样的做法是有漏洞的：如果删除的是最后一个节点，那么是找不到后继节点的，只能老老实实地找到前置节点，并使前置节点的 next 赋为 null

4. 但是这样还是有漏洞的：如果删除节点既没有前置、也没有后继呢？换言之，整个链表只有这一个节点，那么只要处理特殊情况即可。

### [22] 链表中倒数第 k 个节点

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。	
>

1. 思路是简单的，双指针解决。本题的主要注意点是代码的鲁棒性
2. 考虑一下情况：
   1. 传入的链表节点为空
   2. 传入的 k 为0或负数
   3. 传入的 k 大于链表长度
   4. 传入的 k 为1（返回链表最后一个节点）
   5. 传入的 k 为链表长度（返回链表第一个节点）



### [24] 反转链表

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

1. 思路依旧是简单的，依旧是注意鲁棒性
2. 考虑以下情况：
   1. 链表不存在
   2. 链表只有一个节点
3. 提示：==哑节点(C语言语境下的"头指针")可以规避大部分特殊情况的判断。==

## 树

### [07] 重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

1. 考察了二叉树的遍历特性。二叉树可以通过 前+中，或者 后+中 推断出整个二叉树的原样。知道 前+后 是不能推导出来的。
2. ~~道理我都懂可是怎么能保证自己把代码写出来呢淦~~
3. 这一题这次并没有写出来。说明自己代码能力没有跟上思维。





### [26] 树的子结构

> 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
>
> B是A的子结构， 即 A中有出现和B相同的结构和节点值。

1. 首先在A中找与B根节点相同的节点
2. 然后判断A是否包含了整个 B

```java
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (A == null || B == null) {
            return false;
        }
        if (A.val == B.val && isEqual(A, B)) {
            return true;
        }
        boolean condition2 = isSubStructure(A.left, B);
        boolean condition3 = isSubStructure(A.right, B);
        return condition2 || condition3;
    }
    private boolean isEqual(TreeNode STree, TreeNode DTree) {
        if(DTree == null){
            return true;
        }
        if(STree == null){
            return false;
        }
        return (STree.val == DTree.val)
            && isEqual(STree.left, DTree.left)
            && isEqual(STree.right, DTree.right);
    }
```

踩坑：

1. 思路比较容易想到，但是提交了两次才改对。
2. 第一次在于，在第二步的递归中，如果 B 为 null 了，说明已经找完了，返回成功。
3. 第二次是，在第一步判断时，如果 B 是空节点，直接返回没找到。

==判断空指针啊！在任意使用节点的成员属性时都要想想是否可能为 null！==

### [33] 二叉搜索树的后序遍历序列

> 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

1. 输入只给出了一个整数数组，说明并不指定是哪个二叉树的后序遍历，而是 **是否有可能成为某个二叉树的后序遍历序列**。
2. 即：判断这个序列是否满足后序序列的特性，最后一个数为根，剩下的结点应该先全部小于根，后全部大于根。
3. 对于一个序列，首先获取其末尾元素。遍历并检查剩下的元素，先小后大。

```java
public boolean verifyPostorder(int[] postorder) {
    return helper(postorder, 0, postorder.length);
}
private boolean helper(int[] postorder, int start,int end){
        if(start >= end-1){
            return true;
        }
        int root = postorder[end-1];
        int index = -1;
        for (int i = start; i < end-1; i++) {
            if(postorder[i]>=root){
                // 直到找到第一个大于等于根的
                index = i;
                break;
            }
        }
        if(index != -1){
            // 如果全部小于根，那么没必要走这一步
            for (int i = index; i < end-1; i++) {
                if(postorder[i]<root){
                    // 之后不应该有小于根的
                    return false;
                }
            }
            return helper(postorder, start, index) && helper(postorder, index, end - 1);
        }
    	// 如果全部小于根，那么接着判断除了根的区间
        return helper(postorder, start, end - 1);
}
```





### [34] 二叉树中和为某一值的路径

> 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

1. 其实大部分树的题目都是基于遍历的，这一点大家都知道。问题在于怎么解决掉非遍历的部分。
2. 比如本题，问题在于，如何保存遍历下来的数组？如何在找到合适路径的时候把这个数组添加进结果集中？
3. 答案是：在类中定义 res 和 path 列表，这样在不同的递归方法中可以共享资源。在新进入一个结点时，将 val 值放入 path 中，在离开时从 path 中移除最后的元素。
4. 但是还会带来的问题是：由于列表是引用的，因此彼此的改变会改变已经存储好的路径。那么也就是说，将 path 放入 res 中时，必须要复制一份 path 才行。

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        helper(root, sum);
        return ans;
    }

    void helper(TreeNode node, int sum) {
        if (node == null) {
            return;
        }
        path.add(node.val);
        if (node.val == sum && node.left == null && node.right == null) {
            ans.add(new ArrayList<>(path));
        }
        helper(node.left, sum - node.val);
        helper(node.right, sum - node.val);
        path.remove(path.size() - 1);
        return;
    }
}
```



### [55] 二叉树的深度

> 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

这还不叫送分题？？？

```java
public int maxDepth(TreeNode root) {
    return (root == null) ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1;
}
```



